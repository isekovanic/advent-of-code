import sys
import re

sys.path.append('../../')

from Core import SolverCore

# I don't think that this problem has any significant way of finding a solution other than
# experimentation. We neither know what a Christmas tree looks like nor how to heuristically find one.
# I guess the best bet would maybe be to try to find a step (seconds passed) where the largest
# connected component is as large as possible within some predefined confines of steps but without
# knowing the shape of the tree that's also very easily disprovable (let's say that the tree is
# "zoomed out" and we have a space between each * character that represents it).
# It would definitely work for the tree in all of the test cases I've seen but it didn't feel right
# implementing that after we know what it looks like. I might add an alternative solution at some point.
# Anyway, my solution outputs the given "states" of the grid to a file so that you can easily search
# for the tree in there. If the window is low enough (3000-5000 grids for example), you can easily spot
# the outlier and find the step of your tree.
# The "solution" will be in the tree.txt file generated by the code.
class Solver(SolverCore):
    def _solve(self, problem_input):
        robots = [[int(x) for x in re.findall('-?[0-9]+', line.strip())] for line in problem_input]
        tree_file = open('tree.txt', 'a')
        tree_file.truncate(0)
        dimx, dimy = 101, 103
        
        s_from, s_to = 5000, 10000
        step = s_from
        
        while s_from <= step <= s_to:
            tree_file.write(str(step) + '\n')
            tree = [['.' for _ in range(dimx)] for _ in range(dimy)]
            for robot in robots:
                sx, sy, vx, vy = robot
                nx, ny = (sx + vx * step) % dimx, (sy + vy * step) % dimy
                tree[ny][nx] = '*'
            to_test = '\n'.join([''.join(x) for x in tree])
            
            tree_file.write(to_test + '\n')
            tree_file.write('====================\n')
            
            step += 1
        
        return 0


solver = Solver(0)
solver.solve()
